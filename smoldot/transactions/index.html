<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Transactions handling."><meta name="keywords" content="rust, rustlang, rust-lang, transactions"><title>smoldot::transactions - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../smoldot/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module transactions</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><div id="sidebar-vars" data-name="transactions" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">smoldot</a>::<wbr><a class="mod" href="#">transactions</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/smoldot/transactions.rs.html#18-107" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Transactions handling.</p>
<p>This module contains everything related to the handling of transactions.</p>
<h1 id="overview" class="section-header"><a href="#overview">Overview</a></h1>
<p>From a thousand miles perspective, the process of including a transaction in the chain is as
follows:</p>
<ul>
<li>
<p>The transaction gets built, in other words the bytes that encode the transaction are
generated. This can be done for example through a UI, through an offchain worker, or other. A
transaction can be either signed (i.e. have a signature attached to it) or unsigned, depending
on the action to be performed. A balance transfer, for example, generally always requires a
signature.</p>
</li>
<li>
<p>The transaction is then processed by a node, generally the node that belongs to the author
of the transaction, where it is <em>validated</em> by passing it as parameter to a runtime entry
point. See the <a href="validate/index.html" title="validate"><code>validate</code></a> module for more info. The <a href="pool/index.html" title="pool"><code>pool</code></a> module contains a data
structure that manages the list of pending transactions.</p>
</li>
<li>
<p>If the validation process indicates that the transaction can be propagated, it is then sent
over the peer-to-peer network to other peers. Each node that receives the transaction
similarly validates it and relays it to its own peers.</p>
</li>
<li>
<p>When a block is authored, the node that authors it picks from its pool of validated
transactions the ones to include in the block. The logic under which transactions are picked
and their ordering depends on the output of the validation. The <em>body</em> of the newly-authored
block is made of (but not exclusively) the transactions that have been included in said block.</p>
</li>
<li>
<p>When a node receives a new block, the transactions in the pool are re-validated against
this block. The validation function found in the runtime is expected to return an error if
the transaction in question is already present in the chain and should not be included again.</p>
</li>
</ul>
<h2 id="about-duplicate-transactions" class="section-header"><a href="#about-duplicate-transactions">About duplicate transactions</a></h2>
<p>In practice, the vast majority of the time, a given transaction can only ever be inserted
once in a chain, as the vast majority of transactions include some sort of nonce in their
encoding. In other words, once a transaction has been included in a block, trying to
re-validate that same transaction against that same block or any of its descendants will
return an error.</p>
<p>Once a transaction has been included in a block, it becomes known to everyone. If the runtime
<em>always</em> considered a certain transaction as valid, then this transaction could be repeatedly
included in the chain over and over again (and by anyone, since the transaction is public).
On a higher level, the logic of such a transaction couldn’t possibly make sense, as the reason
why transactions exist in the first place is to modify the state of the chain. In other words,
a runtime that always considers a certain transaction to be valid doesn’t make sense on a
higher level.</p>
<p>With that in mind, a Substrate/Polkadot client implementation is allowed to make two
assumptions:</p>
<ul>
<li>After a transaction has been included in a block, trying to re-validate it against that
same block or any of its descendants always yields an error.</li>
<li>The same transaction can’t possibly be included twice in the same block.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The official Substrate client, in particular, tracks transactions by their hash,
and removes from the pool any transaction from the pool after it has been included
in the best chain, without even attempting to re-validate it (but re-inserts
transactions in the pool if a block gets reverted).</p>
</blockquote>
<p>However, this is in theory not the correct behaviour. A legitimate (but in practice very
uncommon) use-case for runtimes is to consider a transaction as invalid right after it has
been included, but then valid again some time in the future.</p>
<p>The specific use case is considered to be uncommon enough to not explicitly be taken into
account. The client considers that once a transaction has been considered invalid against a
certain block B, it will forever remain considered as invalid on any descendant of B, but a
client also attempts to not cache that information for <em>too long</em> through heuristics.</p>
<h2 id="about-length-prefixes" class="section-header"><a href="#about-length-prefixes">About length prefixes</a></h2>
<p>The meaning of the bytes that a transaction consists of depends on the runtime. It is typically
some sort of <code>enum</code>, and the first byte consists in a discriminant.</p>
<p>Similar objects, such as the block header, are typically passed as to the runtime in their
SCALE encoding. Transactions, however, for historical reasons, are passed in their
double-SCALE-encoding. In other words, transactions are first encoded in SCALE, then prepended
with a SCALE-compact-encoded integer containing their length.</p>
<p>Transactions are similarly passed over the network in their double-SCALE-encoding.</p>
<p>A block body consists in a SCALE-encoded <code>Vec&lt;Vec&lt;u8&gt;&gt;</code>, where each of the inner <code>Vec&lt;u8&gt;</code> is
a (single) SCALE-encoded transaction. A block body is therefore the concatenation of all the
double-SCALE-encoded transactions.</p>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="light_pool/index.html" title="smoldot::transactions::light_pool mod">light_pool</a></div><div class="item-right docblock-short"><p>Transactions pool specialized for light clients usage.</p>
</div><div class="item-left module-item"><a class="mod" href="pool/index.html" title="smoldot::transactions::pool mod">pool</a></div><div class="item-right docblock-short"><p>General-purpose transactions pool.</p>
</div><div class="item-left module-item"><a class="mod" href="validate/index.html" title="smoldot::transactions::validate mod">validate</a></div><div class="item-right docblock-short"><p>Runtime call to obtain the transactions validity status.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="smoldot" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script>
</body></html>