<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Wasm virtual machine specific to the Substrate&#x2F;Polkadot Runtime Environment."><meta name="keywords" content="rust, rustlang, rust-lang, host"><title>smoldot::executor::host - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../smoldot/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module host</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div><div id="sidebar-vars" data-name="host" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">smoldot</a>::<wbr><a href="../index.html">executor</a>::<wbr><a class="mod" href="#">host</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/smoldot/executor/host.rs.html#18-2610" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Wasm virtual machine specific to the Substrate/Polkadot Runtime Environment.</p>
<p>Contrary to <a href="../vm/struct.VirtualMachine.html"><code>VirtualMachine</code></a>, this code is not just a generic
Wasm virtual machine, but is aware of the Substrate/Polkadot runtime environment. The host
functions that the Wasm code calls are automatically resolved and either handled or notified
to the user of this module.</p>
<p>Any host function that requires pure CPU computations (for example building or verifying
a cryptographic signature) is directly handled by the code in this module. Other host
functions (for example accessing the state or printing a message) are instead handled by
interrupting the virtual machine and waiting for the user of this module to handle the call.</p>
<blockquote>
<p><strong>Note</strong>: The <code>ext_offchain_random_seed_version_1</code> and <code>ext_offchain_timestamp_version_1</code>
functions, which requires the host to respectively produce a random seed and
return the current time, must also be handled by the user. While these functions
could theoretically be handled directly by this module, it might be useful for
testing purposes to have the possibility to return a deterministic value.</p>
</blockquote>
<p>Contrary to most programs, runtime code doesn’t have a singe <code>main</code> or <code>start</code> function.
Instead, it exposes several entry points. Which one to call indicates which action it has to
perform. Not all entry points are necessarily available on all runtimes.</p>
<h1 id="runtime-requirements" class="section-header"><a href="#runtime-requirements">Runtime requirements</a></h1>
<p>See the <a href="../vm/index.html">documentation of the <code>vm</code> module</a> for details about the requirements a
runtime must adhere to.</p>
<p>In addition to the requirements described there, the WebAssembly runtime code can also be
zstandard-compressed and must also export a global symbol named <code>__heap_base</code>.
More details below.</p>
<h2 id="zstandard-compression" class="section-header"><a href="#zstandard-compression">Zstandard compression</a></h2>
<p>The runtime code passed as parameter to <a href="struct.HostVmPrototype.html#method.new" title="HostVmPrototype::new"><code>HostVmPrototype::new</code></a> can be compressed using the
<a href="https://en.wikipedia.org/wiki/Zstandard">zstd</a> algorithm.</p>
<p>If the code starts with the magic bytes <code>[82, 188, 83, 118, 70, 219, 142, 5]</code>, then it is
assumed that the rest of the data is a zstandard-compressed WebAssembly module.</p>
<h2 id="memory-allocations" class="section-header"><a href="#memory-allocations">Memory allocations</a></h2>
<p>One of the instructions available in WebAssembly code is
<a href="https://webassembly.github.io/spec/core/bikeshed/#-hrefsyntax-instr-memorymathsfmemorygrow">the <code>memory.grow</code> instruction</a>,
which allows increasing the size of the memory.</p>
<p>WebAssembly code is normally intended to perform its own heap-management logic internally, and
use the <code>memory.grow</code> instruction if more memory is needed.</p>
<p>In order to minimize the size of the runtime binary, and in order to accomodate for the API of
the host functions that return a buffer of variable length, the Substrate/Polkadot runtimes,
however, do not perform their heap management internally. Instead, they use the
<code>ext_allocator_malloc_version_1</code> and <code>ext_allocator_free_version_1</code> host functions for this
purpose. Calling <code>memory.grow</code> is forbidden.</p>
<p>Consequently, the size of the memory available to the WebAssembly virtual machine is always
fixed, and is equal to the initial size of the memory plus the value of <code>heap_pages</code> that is
passed as parameter to <a href="struct.HostVmPrototype.html#method.new" title="HostVmPrototype::new"><code>HostVmPrototype::new</code></a>.</p>
<p>Additionally, the runtime code must export a global symbol named <code>__heap_base</code> of type <code>i32</code>.
Any memory whose offset is below the value of <code>__heap_base</code> can be used at will by the
program, while any memory above this value is available for use by the implementation of
<code>ext_allocator_malloc_version_1</code>.</p>
<h2 id="entry-points" class="section-header"><a href="#entry-points">Entry points</a></h2>
<p>All entry points that can be called from the host (using, for example,
<a href="struct.HostVmPrototype.html#method.run" title="HostVmPrototype::run"><code>HostVmPrototype::run</code></a>) have the same signature:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
(<span class="ident">func</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">runtime_entry</span>(<span class="ident">param</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">data</span> <span class="ident">i32</span>) (<span class="ident">param</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">len</span> <span class="ident">i32</span>) (<span class="ident">result</span> <span class="ident">i64</span>))</pre></div>
<p>In order to call into the runtime, one must write a buffer of data containing the input
parameters into the Wasm virtual machine’s memory, then pass a pointer and length of this
buffer as the parameters of the entry point.</p>
<p>The function returns a 64bits number. The 32 less significant bits represent a pointer to the
Wasm virtual machine’s memory, and the 32 most significant bits a length. This pointer and
length designate a buffer containing the actual return value.</p>
<h2 id="host-functions" class="section-header"><a href="#host-functions">Host functions</a></h2>
<p>The list of host functions available to the runtime is long and isn’t documented here. See
the official specification for details.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>The first step is to create a <a href="struct.HostVmPrototype.html" title="HostVmPrototype"><code>HostVmPrototype</code></a> object from the WebAssembly code. Creating
this object performs some initial steps, such as parsing and compiling the WebAssembly code.
You are encouraged to maintain a cache of <a href="struct.HostVmPrototype.html" title="HostVmPrototype"><code>HostVmPrototype</code></a> objects (one instance per
WebAssembly byte code) in order to avoid performing these operations too often.</p>
<p>To start calling the runtime, create a <a href="enum.HostVm.html" title="HostVm"><code>HostVm</code></a> by calling <a href="struct.HostVmPrototype.html#method.run" title="HostVmPrototype::run"><code>HostVmPrototype::run</code></a>.</p>
<p>While the Wasm runtime code has side-effects (such as storing values in the storage), the
<a href="enum.HostVm.html" title="HostVm"><code>HostVm</code></a> itself is a pure state machine with no side effects.</p>
<p>At any given point, you can examine the <a href="enum.HostVm.html" title="HostVm"><code>HostVm</code></a> in order to know in which state the
execution currently is.
In case of a <a href="enum.HostVm.html#variant.ReadyToRun" title="HostVm::ReadyToRun"><code>HostVm::ReadyToRun</code></a> (which initially is the case when you create the
<a href="enum.HostVm.html" title="HostVm"><code>HostVm</code></a>), you can execute the Wasm code by calling <a href="struct.ReadyToRun.html#method.run" title="ReadyToRun::run"><code>ReadyToRun::run</code></a>.
No background thread of any kind is used, and calling <a href="struct.ReadyToRun.html#method.run" title="ReadyToRun::run"><code>ReadyToRun::run</code></a> directly performs
the execution of the Wasm code. If you need parallelism, you are encouraged to spawn a
background thread yourself and call this function from there.
<a href="struct.ReadyToRun.html#method.run" title="ReadyToRun::run"><code>ReadyToRun::run</code></a> tries to make the execution progress as much as possible, and returns
the new state of the virtual machine once that is done.</p>
<p>If the runtime has finished, or has crashed, or wants to perform an operation with side
effects, then the <a href="enum.HostVm.html" title="HostVm"><code>HostVm</code></a> determines what to do next. For example, for
<a href="enum.HostVm.html#variant.ExternalStorageGet" title="HostVm::ExternalStorageGet"><code>HostVm::ExternalStorageGet</code></a>, you must load a value from the storage and pass it back by
calling <a href="struct.ExternalStorageGet.html#method.resume" title="ExternalStorageGet::resume"><code>ExternalStorageGet::resume</code></a>.</p>
<p>The Wasm execution is fully deterministic, and the outcome of the execution only depends on
the inputs. There is, for example, no implicit injection of randomness or of the current time.</p>
<h2 id="example" class="section-header"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">smoldot::executor::host</span>::{<span class="ident">HeapPages</span>, <span class="ident">HostVm</span>, <span class="ident">HostVmPrototype</span>};


<span class="comment">// Start executing a function on the runtime.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vm</span>: <span class="ident">HostVm</span> <span class="op">=</span> {
    <span class="kw">let</span> <span class="ident">prototype</span> <span class="op">=</span> <span class="ident">HostVmPrototype::new</span>(
        <span class="kw-2">&amp;</span><span class="ident">wasm_binary_code</span>,
        <span class="ident">HeapPages::from</span>(<span class="number">2048</span>),
        <span class="ident">smoldot::executor::vm::ExecHint::Oneshot</span>
    ).<span class="ident">unwrap</span>();
    <span class="ident">prototype</span>.<span class="ident">run_no_param</span>(<span class="string">&quot;Core_version&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">into</span>()
};

<span class="comment">// We need to answer the calls that the runtime might perform.</span>
<span class="kw">loop</span> {
    <span class="kw">match</span> <span class="ident">vm</span> {
        <span class="comment">// Calling `runner.run()` is what actually executes WebAssembly code and updates</span>
        <span class="comment">// the state.</span>
        <span class="ident">HostVm::ReadyToRun</span>(<span class="ident">runner</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">runner</span>.<span class="ident">run</span>(),

        <span class="ident">HostVm::Finished</span>(<span class="ident">finished</span>) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="comment">// `finished.value()` here is an opaque blob of bytes returned by the runtime.</span>
            <span class="comment">// In the case of a call to `&quot;Core_version&quot;`, we know that it must be empty.</span>
            <span class="macro">assert!</span>(<span class="ident">finished</span>.<span class="ident">value</span>().<span class="ident">as_ref</span>().<span class="ident">is_empty</span>());
            <span class="macro">println!</span>(<span class="string">&quot;Success!&quot;</span>);
            <span class="kw">break</span>;
        },

        <span class="comment">// Errors can happen if the WebAssembly code panics or does something wrong.</span>
        <span class="comment">// In a real-life situation, the host should obviously not panic in these situations.</span>
        <span class="ident">HostVm::Error</span> { .. } <span class="op">=</span><span class="op">&gt;</span> {
            <span class="macro">panic!</span>(<span class="string">&quot;Error while executing code&quot;</span>)
        },

        <span class="comment">// All the other variants correspond to function calls that the runtime might perform.</span>
        <span class="comment">// `ExternalStorageGet` is shown here as an example.</span>
        <span class="ident">HostVm::ExternalStorageGet</span>(<span class="ident">req</span>) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="macro">println!</span>(<span class="string">&quot;Runtime requires the storage value at {:?}&quot;</span>, <span class="ident">req</span>.<span class="ident">key</span>().<span class="ident">as_ref</span>());
            <span class="comment">// Injects the value into the virtual machine and updates the state.</span>
            <span class="ident">vm</span> <span class="op">=</span> <span class="ident">req</span>.<span class="ident">resume</span>(<span class="prelude-val">None</span>); <span class="comment">// Just a stub</span>
        }
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">unimplemented!</span>()
    }
}</pre></div>
</div></details><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<div class="item-table"><div class="item-left import-item"><code>pub use vm::<a class="struct" href="../vm/struct.HeapPages.html" title="struct smoldot::executor::vm::HeapPages">HeapPages</a>;</code></div><div class="item-right docblock-short"></div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.CallRuntimeVersion.html" title="smoldot::executor::host::CallRuntimeVersion struct">CallRuntimeVersion</a></div><div class="item-right docblock-short"><p>Must provide the runtime version obtained by calling the <code>Core_version</code> entry point of a Wasm
blob.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.EndStorageTransaction.html" title="smoldot::executor::host::EndStorageTransaction struct">EndStorageTransaction</a></div><div class="item-right docblock-short"><p>Declares the end of a transaction.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ExternalOffchainStorageSet.html" title="smoldot::executor::host::ExternalOffchainStorageSet struct">ExternalOffchainStorageSet</a></div><div class="item-right docblock-short"><p>Must set the value of the offchain storage.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ExternalStorageAppend.html" title="smoldot::executor::host::ExternalStorageAppend struct">ExternalStorageAppend</a></div><div class="item-right docblock-short"><p>Must load a storage value, treat it as if it was a SCALE-encoded container, and put <code>value</code>
at the end of the container, increasing the number of elements.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ExternalStorageChangesRoot.html" title="smoldot::executor::host::ExternalStorageChangesRoot struct">ExternalStorageChangesRoot</a></div><div class="item-right docblock-short"><p>Must provide the trie root hash of the changes trie.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ExternalStorageClearPrefix.html" title="smoldot::executor::host::ExternalStorageClearPrefix struct">ExternalStorageClearPrefix</a></div><div class="item-right docblock-short"><p>Must remove from the storage keys which start with a certain prefix. Use
<a href="struct.ExternalStorageClearPrefix.html#method.max_keys_to_remove" title="ExternalStorageClearPrefix::max_keys_to_remove"><code>ExternalStorageClearPrefix::max_keys_to_remove</code></a> to determine the maximum number of keys
to remove.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ExternalStorageGet.html" title="smoldot::executor::host::ExternalStorageGet struct">ExternalStorageGet</a></div><div class="item-right docblock-short"><p>Must provide the value of a storage entry.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ExternalStorageNextKey.html" title="smoldot::executor::host::ExternalStorageNextKey struct">ExternalStorageNextKey</a></div><div class="item-right docblock-short"><p>Must provide the storage key that follows, in lexicographic order, a specific one.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ExternalStorageRoot.html" title="smoldot::executor::host::ExternalStorageRoot struct">ExternalStorageRoot</a></div><div class="item-right docblock-short"><p>Must provide the trie root hash of the storage.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ExternalStorageSet.html" title="smoldot::executor::host::ExternalStorageSet struct">ExternalStorageSet</a></div><div class="item-right docblock-short"><p>Must set the value of a storage entry.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Finished.html" title="smoldot::executor::host::Finished struct">Finished</a></div><div class="item-right docblock-short"><p>Function execution has succeeded. Contains the return value of the call.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.HostVmPrototype.html" title="smoldot::executor::host::HostVmPrototype struct">HostVmPrototype</a></div><div class="item-right docblock-short"><p>Prototype for an <a href="enum.HostVm.html" title="HostVm"><code>HostVm</code></a>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.LogEmit.html" title="smoldot::executor::host::LogEmit struct">LogEmit</a></div><div class="item-right docblock-short"><p>Report about a log entry being emitted.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ReadyToRun.html" title="smoldot::executor::host::ReadyToRun struct">ReadyToRun</a></div><div class="item-right docblock-short"><p>Virtual machine is ready to run.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.StartStorageTransaction.html" title="smoldot::executor::host::StartStorageTransaction struct">StartStorageTransaction</a></div><div class="item-right docblock-short"><p>Declares the start of a transaction.</p>
</div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="smoldot::executor::host::Error enum">Error</a></div><div class="item-right docblock-short"><p>Reason why the Wasm blob isn’t conforming to the runtime environment.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.HostVm.html" title="smoldot::executor::host::HostVm enum">HostVm</a></div><div class="item-right docblock-short"><p>Running virtual machine.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.ModuleFormatError.html" title="smoldot::executor::host::ModuleFormatError enum">ModuleFormatError</a></div><div class="item-right docblock-short"><p>Error possibly returned when decoding a zstd-compressed Wasm blob.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.NewErr.html" title="smoldot::executor::host::NewErr enum">NewErr</a></div><div class="item-right docblock-short"><p>Error that can happen when initializing a VM.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.StartErr.html" title="smoldot::executor::host::StartErr enum">StartErr</a></div><div class="item-right docblock-short"><p>Error that can happen when starting a VM.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="smoldot" data-search-index-js="../../../search-index.js" data-search-js="../../../search.js"></div>
    <script src="../../../main.js"></script>
</body></html>